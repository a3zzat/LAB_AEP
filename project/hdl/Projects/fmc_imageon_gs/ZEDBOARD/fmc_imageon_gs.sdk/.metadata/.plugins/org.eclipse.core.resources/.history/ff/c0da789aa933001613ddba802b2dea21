/*
 * main.c
 *
 *  Created on: Aug 1, 2014
 *      Author: 910560
 */

#include "demo.h"
#include "avnet_console.h"
#include "avnet_console_serial.h"

#include "audio.h"

#include "netif/xadapter.h"
#include "lwip/err.h"
#include "lwip/udp.h"

#include "xparameters.h"
#include "xscugic.h"
#include "fifo.h"

#include <stdio.h>

demo_t demo;
demo_t *pdemo;

u32 Audio[2];

/////////////////////////////////////////////////////////////////////////////////////////
struct netif server_netif;		//variables for network interfaces
struct ip_addr ipaddr_s, netmask, gw;		//IP addresses storage

/* the MAC address of the board. this should be unique per board */
unsigned char mac_ethernet_address[] = { 0x00, 0x0a, 0x35, 0x00, 0x01, 0x02 };
//unsigned char mac_ethernet_address[] = {0x68,0x5B,0x35,0xB7,0xCA,0x9D};

//	xil_printf("version = %X\r\n", Xil_In32(XPAR_EVALUATOR_0_BASEADDR + EVAL_VERSION));

/////////////////////////////////////////////////////////////////////////////////////////
Client* current_client, *next_client;
struct pbuf *pBuffer;

struct udp_pcb *udp;		//a pointer to a UDP header structure
XScuGic ScuGic;
int setup_interrupt();

void udp_recv_callback(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port);
void lwip_init();	// missing declaration in lwIP

/////////////////////////////////////////////////////////////////////////////////////////
///// These functions are used to print out IP address information /////
void print_ip(char *msg, struct ip_addr *ip) {
	print(msg);
	xil_printf("%d.%d.%d.%d\n\r", ip4_addr1(ip) , ip4_addr2(ip), ip4_addr3(ip), ip4_addr4(ip));
}

void print_ip_settings(struct ip_addr *ip, struct ip_addr *mask, struct ip_addr *gw) {

	print_ip("Board IP: ", ip);
	print_ip("Netmask : ", mask);
	print_ip("Gateway : ", gw);
}
/////////////////////////////////////////////////////////////////////////////////////////
void net_init() {

	///// Initialize the Interrupt controller variable
	if (setup_interrupt() != XST_SUCCESS)
		xil_printf("interrupt error\r\n");

	/////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////// Initialize network interface and IP protocol //////////////

	/* Initialize IP addresses to be used: change this between boards*/
	//IP4_ADDR(&ipaddr_s, 192, 168, 2, 11);  //local ip address
	//IP4_ADDR(&ipaddr_s,  130, 149,   224, 6);  //remote ip address
	IP4_ADDR(&ipaddr_s,  130,149,224,26);
	IP4_ADDR(&netmask, 255, 255, 255, 0);
	IP4_ADDR(&gw, 130, 149, 224, 1);
	//IP4_ADDR(&gw, 192, 168, 2, 10);
	//IP4_ADDR(&gw, 130, 149, 224, 43);

	print_ip_settings(&ipaddr_s, &netmask, &gw);
	//print_ip_settings(&ipaddr_d, &netmask, &gw);

	lwip_init();	///////// initialize the light weight IP library

	/* Add network interface to the netif_list, and set it as default */
	if (!xemac_add(&server_netif, &ipaddr_s, &netmask, &gw, mac_ethernet_address, XPAR_XEMACPS_0_BASEADDR)) {
		xil_printf("Error adding N/W interface\n\r");
		return -1;
	}

	netif_set_default(&server_netif);	// set the registered MAC interface as the default interface
	netif_set_up(&server_netif);		// specify that the network is up
	///////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////Prepare UDB Protocol////////////////////////
	if (NULL == (udp = udp_new()))	//initialize the UDB header
		xil_printf("Problems initializing UDB!\n\r");

	//par1.udp = udp; // fill out the UDP pointer of the interrupt handler input argument
	//par1.ipaddr_s = &ipaddr_s;
	//par1.ipaddr_d = &ipaddr_d;

	if (ERR_OK != udp_bind(udp, &ipaddr_s, 5000))		//initialize the local binding process on port 10024
		xil_printf("Problems binding address!\n\r");

	/// we will use port 10024 for communication using UDB protocol
	/// these calls initialize the connection and binding process

	udp_recv(udp, udp_recv_callback, NULL ); //register the function recv_callback as the call back for incoming functions
											 //this function will be called to process incoming package
	///////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////

	//initialize buffer for udp protocol
	pBuffer = pbuf_alloc(PBUF_RAW, sizeof(Audio), PBUF_REF);
	pBuffer->payload = &Audio; // to fill with our data
	/////////////////////////////////////////////////////////////////////////////////////////
//	xil_printf("version = %X\r\n", Xil_In32(XPAR_EVALUATOR_0_BASEADDR + EVAL_VERSION));

		/////////////////////////////////////////////////////////////////////////////////////////
		///// Initialize the Interrupt controller variable
		if (setup_interrupt() != XST_SUCCESS)
			xil_printf("interrupt error\r\n");

		/////////////////////////////////////////////////////////////////////////////////////////
		///////////////////////////// Initialize network interface and IP protocol //////////////

		/* Initialize IP addresses to be used: change this between boards*/
		//IP4_ADDR(&ipaddr_s, 192, 168, 2, 11);  //local ip address
		//IP4_ADDR(&ipaddr_s,  130, 149,   224, 6);  //remote ip address
		IP4_ADDR(&ipaddr_s,  130,149,224,26);
		IP4_ADDR(&netmask, 255, 255, 255, 0);
		IP4_ADDR(&gw, 130, 149, 224, 1);
		//IP4_ADDR(&gw, 192, 168, 2, 10);
		//IP4_ADDR(&gw, 130, 149, 224, 43);

		print_ip_settings(&ipaddr_s, &netmask, &gw);
		//print_ip_settings(&ipaddr_d, &netmask, &gw);

		lwip_init();	///////// initialize the light weight IP library

		/* Add network interface to the netif_list, and set it as default */
		if (!xemac_add(&server_netif, &ipaddr_s, &netmask, &gw, mac_ethernet_address, XPAR_XEMACPS_0_BASEADDR)) {
			xil_printf("Error adding N/W interface\n\r");
			return -1;
		}

		netif_set_default(&server_netif);	// set the registered MAC interface as the default interface
		netif_set_up(&server_netif);		// specify that the network is up
		///////////////////////////////////////////////////////////////////////////////

		///////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////Prepare UDB Protocol////////////////////////
		if (NULL == (udp = udp_new()))	//initialize the UDB header
			xil_printf("Problems initializing UDB!\n\r");

		//par1.udp = udp; // fill out the UDP pointer of the interrupt handler input argument
		//par1.ipaddr_s = &ipaddr_s;
		//par1.ipaddr_d = &ipaddr_d;

		if (ERR_OK != udp_bind(udp, &ipaddr_s, 5000))		//initialize the local binding process on port 10024
			xil_printf("Problems binding address!\n\r");

		/// we will use port 10024 for communication using UDB protocol
		/// these calls initialize the connection and binding process

		udp_recv(udp, udp_recv_callback, NULL ); //register the function recv_callback as the call back for incoming functions
												 //this function will be called to process incoming package
		///////////////////////////////////////////////////////////////////////////////

		///////////////////////////////////////////////////////////////////////////////

		//initialize buffer for udp protocol
		pBuffer = pbuf_alloc(PBUF_RAW, sizeof(face_info_buffer), PBUF_REF);
		pBuffer->payload = &face_info_buffer; // to fill with our data
		/////////////////////////////////////////////////////////////////////////////////////////

}

int main()
{
	Audio_init();

	xil_printf("\n\r");
	xil_printf("------------------------------------------------------\n\r");
	xil_printf("--                    FMC-IMAGEON                   --\n\r");
	xil_printf("--               Getting Started Design             --\n\r");
	xil_printf("------------------------------------------------------\n\r");
	xil_printf("\n\r");


	pdemo = &demo;
	demo_init( pdemo );

	// Init reference design
	demo_init_frame_buffer(pdemo);

	// Try CAM first
	pdemo->cam_alpha = 0xFF;
	pdemo->hdmi_alpha = 0x00;
	if ( !demo_start_cam_in(pdemo) )
	{
		// Then try HDMI
		pdemo->cam_alpha = 0x00;
		pdemo->hdmi_alpha = 0xFF;
		demo_start_hdmi_in(pdemo);
	}
	demo_start_frame_buffer(pdemo);

	// Start serial console
	print_avnet_console_serial_app_header();
	start_avnet_console_serial_application();

	u32 Audio[2];

	while (1)
	{
		read_play(Audio);

		if (transfer_avnet_console_serial_data()) {
			break;
		}

		/// udp server part

		xemacif_input(&server_netif);  // Process incoming packages if any

		// fill buffer

		// fill buffer length
		pBuffer->tot_len = pBuffer->len = sizeof(Audio);
		/// send data
		udp_sendto(udp, pBuffer, &current_client->ipaddr_d, current_client->port_d);
			xil_printf("Sending back some results\r\n");
	}

	return 0;

//    xil_printf("\r\n\tPress 0-9 to change alpha blending of hdmi/camera layers\r\n");
//	xil_printf("\r\n\tPress ENTER to restart\r\n\r\n" );
//	c = getchar();

//	if ( c >= '0' && c <= '9' )
//	{
//		camera_alpha = (c - '0') * 28;
//		hdmi_alpha    = ('9' - c) * 28;
//	}

//	if ( c == '+' )
//	{
//		if ( pdemo->pvita_receiver->uManualTap < 31 )
//			pdemo->pvita_receiver->uManualTap++;
//		xil_printf( "\tuManualTap = %d\n\r", pdemo->pvita_receiver->uManualTap );
//	}
//	if ( c == '-' )
//	{
//		if ( pdemo->pvita_receiver->uManualTap > 0 )
//			pdemo->pvita_receiver->uManualTap--;
//		xil_printf( "\tuManualTap = %d\n\r", pdemo->pvita_receiver->uManualTap );
//	}
//}

	//return 0;
}
