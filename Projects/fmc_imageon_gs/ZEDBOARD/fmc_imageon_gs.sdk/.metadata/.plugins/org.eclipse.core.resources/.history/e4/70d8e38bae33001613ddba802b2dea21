/*
 * main.c
 *
 *  Created on: Aug 1, 2014
 *      Author: 910560
 */

#include "demo.h"
#include "avnet_console.h"
#include "avnet_console_serial.h"

#include "audio.h"

//#include "netif/xadapter.h"
//#include "lwip/err.h"
//#include "lwip/udp.h"
//
//#include "xparameters.h"
//#include "xscugic.h"
////#include "fifo.h"

#include <stdio.h>

demo_t demo;
demo_t *pdemo;

u32 Audio[2];

///////////////////////////////////////////////////////////////////////////////////////////
//struct netif server_netif;		//variables for network interfaces
//struct ip_addr ipaddr_s, netmask, gw;		//IP addresses storage
//
///* the MAC address of the board. this should be unique per board */
//unsigned char mac_ethernet_address[] = { 0x00, 0x0a, 0x35, 0x00, 0x01, 0x02 };
////unsigned char mac_ethernet_address[] = {0x68,0x5B,0x35,0xB7,0xCA,0x9D};
//
////	xil_printf("version = %X\r\n", Xil_In32(XPAR_EVALUATOR_0_BASEADDR + EVAL_VERSION));
//
///////////////////////////////////////////////////////////////////////////////////////////
//Client* current_client, *next_client;
//struct pbuf *pBuffer;
//
//struct udp_pcb *udp;		//a pointer to a UDP header structure
//XScuGic ScuGic;
//int setup_interrupt();
//
//void udp_recv_callback(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port);
//void lwip_init();	// missing declaration in lwIP
//
///////////////////////////////////////////////////////////////////////////////////////////
/////// These functions are used to print out IP address information /////
//void print_ip(char *msg, struct ip_addr *ip) {
//	print(msg);
//	xil_printf("%d.%d.%d.%d\n\r", ip4_addr1(ip) , ip4_addr2(ip), ip4_addr3(ip), ip4_addr4(ip));
//}
//
//void print_ip_settings(struct ip_addr *ip, struct ip_addr *mask, struct ip_addr *gw) {
//
//	print_ip("Board IP: ", ip);
//	print_ip("Netmask : ", mask);
//	print_ip("Gateway : ", gw);
//}
///////////////////////////////////////////////////////////////////////////////////////////
//void udp_recv_callback(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port) {}
//
//void net_init() {
//
//	///// Initialize the Interrupt controller variable
////	if (setup_interrupt() != XST_SUCCESS)
////		xil_printf("interrupt error\r\n");
//
//	/////////////////////////////////////////////////////////////////////////////////////////
//	///////////////////////////// Initialize network interface and IP protocol //////////////
//
//	/* Initialize IP addresses to be used: change this between boards*/
//	//IP4_ADDR(&ipaddr_s, 192, 168, 2, 11);  //local ip address
//	//IP4_ADDR(&ipaddr_s,  130, 149,   224, 6);  //remote ip address
//	IP4_ADDR(&ipaddr_s,  130,149,224,26);
//	IP4_ADDR(&netmask, 255, 255, 255, 0);
//	IP4_ADDR(&gw, 130, 149, 224, 1);
//	//IP4_ADDR(&gw, 192, 168, 2, 10);
//	//IP4_ADDR(&gw, 130, 149, 224, 43);
//
//	print_ip_settings(&ipaddr_s, &netmask, &gw);
//	//print_ip_settings(&ipaddr_d, &netmask, &gw);
//
//	lwip_init();	///////// initialize the light weight IP library
//
//	/* Add network interface to the netif_list, and set it as default */
//	if (!xemac_add(&server_netif, &ipaddr_s, &netmask, &gw, mac_ethernet_address, XPAR_XEMACPS_0_BASEADDR)) {
//		xil_printf("Error adding N/W interface\n\r");
//		return -1;
//	}
//
//	netif_set_default(&server_netif);	// set the registered MAC interface as the default interface
//	netif_set_up(&server_netif);		// specify that the network is up
//	///////////////////////////////////////////////////////////////////////////////
//
//	///////////////////////////////////////////////////////////////////////////////
//	///////////////////////////////////Prepare UDB Protocol////////////////////////
//	if (NULL == (udp = udp_new()))	//initialize the UDB header
//		xil_printf("Problems initializing UDB!\n\r");
//
//	//par1.udp = udp; // fill out the UDP pointer of the interrupt handler input argument
//	//par1.ipaddr_s = &ipaddr_s;
//	//par1.ipaddr_d = &ipaddr_d;
//
//	if (ERR_OK != udp_bind(udp, &ipaddr_s, 5000))		//initialize the local binding process on port 10024
//		xil_printf("Problems binding address!\n\r");
//
//	/// we will use port 10024 for communication using UDB protocol
//	/// these calls initialize the connection and binding process
//
//	udp_recv(udp, udp_recv_callback, NULL ); //register the function recv_callback as the call back for incoming functions
//											 //this function will be called to process incoming package
//	///////////////////////////////////////////////////////////////////////////////
//
//	///////////////////////////////////////////////////////////////////////////////
//
//	//initialize buffer for udp protocol
//	pBuffer = pbuf_alloc(PBUF_RAW, sizeof(Audio), PBUF_REF);
//	pBuffer->payload = &Audio; // to fill with our data
//	/////////////////////////////////////////////////////////////////////////////////////////
////	xil_printf("version = %X\r\n", Xil_In32(XPAR_EVALUATOR_0_BASEADDR + EVAL_VERSION));
//
//		/////////////////////////////////////////////////////////////////////////////////////////
//		///// Initialize the Interrupt controller variable
////		if (setup_interrupt() != XST_SUCCESS)
////			xil_printf("interrupt error\r\n");
//
//		/////////////////////////////////////////////////////////////////////////////////////////
//		///////////////////////////// Initialize network interface and IP protocol //////////////
//
//		/* Initialize IP addresses to be used: change this between boards*/
//		//IP4_ADDR(&ipaddr_s, 192, 168, 2, 11);  //local ip address
//		//IP4_ADDR(&ipaddr_s,  130, 149,   224, 6);  //remote ip address
//		IP4_ADDR(&ipaddr_s,  130,149,224,26);
//		IP4_ADDR(&netmask, 255, 255, 255, 0);
//		IP4_ADDR(&gw, 130, 149, 224, 1);
//		//IP4_ADDR(&gw, 192, 168, 2, 10);
//		//IP4_ADDR(&gw, 130, 149, 224, 43);
//
//		print_ip_settings(&ipaddr_s, &netmask, &gw);
//		//print_ip_settings(&ipaddr_d, &netmask, &gw);
//
//		lwip_init();	///////// initialize the light weight IP library
//
//		/* Add network interface to the netif_list, and set it as default */
//		if (!xemac_add(&server_netif, &ipaddr_s, &netmask, &gw, mac_ethernet_address, XPAR_XEMACPS_0_BASEADDR)) {
//			xil_printf("Error adding N/W interface\n\r");
//			return -1;
//		}
//
//		netif_set_default(&server_netif);	// set the registered MAC interface as the default interface
//		netif_set_up(&server_netif);		// specify that the network is up
//		///////////////////////////////////////////////////////////////////////////////
//
//		///////////////////////////////////////////////////////////////////////////////
//		///////////////////////////////////Prepare UDB Protocol////////////////////////
//		if (NULL == (udp = udp_new()))	//initialize the UDB header
//			xil_printf("Problems initializing UDB!\n\r");
//
//		//par1.udp = udp; // fill out the UDP pointer of the interrupt handler input argument
//		//par1.ipaddr_s = &ipaddr_s;
//		//par1.ipaddr_d = &ipaddr_d;
//
//		if (ERR_OK != udp_bind(udp, &ipaddr_s, 5000))		//initialize the local binding process on port 10024
//			xil_printf("Problems binding address!\n\r");
//
//		/// we will use port 10024 for communication using UDB protocol
//		/// these calls initialize the connection and binding process
//
//		udp_recv(udp, udp_recv_callback, NULL ); //register the function recv_callback as the call back for incoming functions
//												 //this function will be called to process incoming package
//		///////////////////////////////////////////////////////////////////////////////
//
//		///////////////////////////////////////////////////////////////////////////////
//
//		//initialize buffer for udp protocol
//		pBuffer = pbuf_alloc(PBUF_RAW, sizeof(Audio), PBUF_REF);
//		pBuffer->payload = &Audio; // to fill with our data
//		/////////////////////////////////////////////////////////////////////////////////////////
//
//}

#include <stdio.h>
#include <string.h>
#include "lwip/udp.h"
#include "xparameters.h"
#include "netif/xadapter.h"
//#include "platform.h"
//#include "platform_config.h"
#include "lwipopts.h"
#ifndef __PPC__
#include "xil_printf.h"
#endif

void print_headers();
int start_applications();
int transfer_data();
void platform_enable_interrupts();
void lwip_init(void);
void tcp_fasttmr(void);
void tcp_slowtmr(void);

#if LWIP_DHCP==1
extern volatile int dhcp_timoutcntr;
err_t dhcp_start(struct netif *netif);
#endif
extern volatile int TxPerfConnMonCntr;
extern volatile int TcpFastTmrFlag;
extern volatile int TcpSlowTmrFlag;

void print_ip(char *msg, struct ip_addr *ip)
{
    print(msg);
    xil_printf("%d.%d.%d.%d\r\n", ip4_addr1(ip), ip4_addr2(ip),
            ip4_addr3(ip), ip4_addr4(ip));
}

void print_ip_settings(struct ip_addr *ip, struct ip_addr *mask, struct ip_addr *gw)
{
    print_ip("Board IP:       ", ip);
    print_ip("Netmask :       ", mask);
    print_ip("Gateway :       ", gw);
}



int main()
{
	Audio_init();
//	net_init();

	xil_printf("\n\r");
	xil_printf("------------------------------------------------------\n\r");
	xil_printf("--                    FMC-IMAGEON                   --\n\r");
	xil_printf("--               Getting Started Design             --\n\r");
	xil_printf("------------------------------------------------------\n\r");
	xil_printf("\n\r");

	struct netif *netif, server_netif;
	    struct ip_addr ipaddr, netmask, gw;

	    // Added stuff for the creation of a basic UDP
	    err_t error;
	    struct ip_addr ip_remote;
	    struct udp_pcb *udp_1;
	    struct pbuf  *p;
	    char data[8] = "01234567";
	    u16_t  Port = 12;
	    int buflen = 8;
	    int count = 0;

	    /* the mac address of the board. this should be unique per board */
	    unsigned char mac_ethernet_address[] = { 0x00, 0x0a, 0x35, 0x00, 0x01, 0x02 };

	    netif = &server_netif;

	    if (init_platform() < 0) {
	        xil_printf("ERROR initializing platform.\r\n");
	        return -1;
	    }

	    xil_printf("\r\n\r\n");
	    xil_printf("-----lwIP RAW Mode Demo Application ------\r\n");
	    /* initliaze IP addresses to be used */
	#if (LWIP_DHCP==0)
	    IP4_ADDR(&ipaddr,  192, 168,   1, 10);
	    IP4_ADDR(&netmask, 255, 255, 255,  0);
	    IP4_ADDR(&gw,      192, 168,   1,  1);
	    print_ip_settings(&ipaddr, &netmask, &gw);
	#endif
	    lwip_init();

	#if (LWIP_DHCP==1)
	    ipaddr.addr = 0;
	    gw.addr = 0;
	    netmask.addr = 0;
	#endif

	    /* Add network interface to the netif_list, and set it as default */
	    if (!xemac_add(netif, &ipaddr, &netmask, &gw, mac_ethernet_address, PLATFORM_EMAC_BASEADDR)) {
	        xil_printf("Error adding N/W interface\r\n");
	        return -1;
	    }
	    netif_set_default(netif);

	    /* specify that the network if is up */
	    netif_set_up(netif);

	    /* now enable interrupts */
	    platform_enable_interrupts();

	#if (LWIP_DHCP==1)
	    /* Create a new DHCP client for this interface.
	     * Note: you must call dhcp_fine_tmr() and dhcp_coarse_tmr() at
	     * the predefined regular intervals after starting the client.
	     */
	    dhcp_start(netif);
	    dhcp_timoutcntr = 24;
	    TxPerfConnMonCntr = 0;
	    while(((netif->ip_addr.addr) == 0) && (dhcp_timoutcntr > 0)) {
	        xemacif_input(netif);
	        if (TcpFastTmrFlag) {
	            tcp_fasttmr();
	            TcpFastTmrFlag = 0;
	        }
	        if (TcpSlowTmrFlag) {
	            tcp_slowtmr();
	            TcpSlowTmrFlag = 0;
	        }
	    }
	    if (dhcp_timoutcntr <= 0) {
	        if ((netif->ip_addr.addr) == 0) {
	            xil_printf("DHCP Timeout\r\n");
	            xil_printf("Configuring default IP of 192.168.1.10\r\n");
	            IP4_ADDR(&(netif->ip_addr),  192, 168,   1, 10);
	            IP4_ADDR(&(netif->netmask), 255, 255, 255,  0);
	            IP4_ADDR(&(netif->gw),      192, 168,   1,  1);
	        }
	    }
	    /* receive and process packets */
	    print_ip_settings(&(netif->ip_addr), &(netif->netmask), &(netif->gw));
	#endif

	    /* start the application (web server, rxtest, txtest, etc..) */
	   xil_printf("Setup Done");
	    IP4_ADDR(&ip_remote,  192, 168,   1, 11);

	    udp_1 = udp_new();

	    error = udp_bind(udp_1, IP_ADDR_ANY, Port);

	    if (error != 0)
	    {
	        xil_printf("Failed %d\r\n", error);
	    }
	    else if (error == 0)
	    {
	        xil_printf("Success\r\n");
	    }
	    error = udp_connect(udp_1, &ip_remote, Port);
	    if (error != 0)
	    {
	        xil_printf("Failed %d\r\n", error);
	    }
	    else if (error == 0)
	    {
	        xil_printf("Success\r\n");
	    }
	    while (1)
	    {
	         xemacif_input(netif);
	         count++;
	         if (count == 80000)
	         {
	             p = pbuf_alloc(PBUF_TRANSPORT, buflen, PBUF_POOL);
	             if (!p) {
	                 xil_printf("error allocating pbuf\r\n");
	                 return ERR_MEM;
	             }
	             memcpy(p->payload, data, buflen);
	             udp_send(udp_1, p);
	             xil_printf("SEND\r\n");
	             count = 0;
	             pbuf_free(p);
	         }

	     }
//	pdemo = &demo;
//	demo_init( pdemo );
//
//	// Init reference design
//	demo_init_frame_buffer(pdemo);
//
//	// Try CAM first
//	pdemo->cam_alpha = 0xFF;
//	pdemo->hdmi_alpha = 0x00;
//	if ( !demo_start_cam_in(pdemo) )
//	{
//		// Then try HDMI
//		pdemo->cam_alpha = 0x00;
//		pdemo->hdmi_alpha = 0xFF;
//		demo_start_hdmi_in(pdemo);
//	}
//	demo_start_frame_buffer(pdemo);
//
//	// Start serial console
//	print_avnet_console_serial_app_header();
//	start_avnet_console_serial_application();

	u32 Audio[2];

	while (1)
	{
		read_play(Audio);
/*

		/// udp server part

		xemacif_input(&server_netif);  // Process incoming packages if any

		// fill buffer

		// fill buffer length
		pBuffer->tot_len = pBuffer->len = sizeof(Audio);
		/// send data
		udp_sendto(udp, pBuffer, &current_client->ipaddr_d, current_client->port_d);
			xil_printf("Sending back some results\r\n");
*/
//		if (transfer_avnet_console_serial_data()) {
//			break;
//		}

	}

	return 0;

//    xil_printf("\r\n\tPress 0-9 to change alpha blending of hdmi/camera layers\r\n");
//	xil_printf("\r\n\tPress ENTER to restart\r\n\r\n" );
//	c = getchar();

//	if ( c >= '0' && c <= '9' )
//	{
//		camera_alpha = (c - '0') * 28;
//		hdmi_alpha    = ('9' - c) * 28;
//	}

//	if ( c == '+' )
//	{
//		if ( pdemo->pvita_receiver->uManualTap < 31 )
//			pdemo->pvita_receiver->uManualTap++;
//		xil_printf( "\tuManualTap = %d\n\r", pdemo->pvita_receiver->uManualTap );
//	}
//	if ( c == '-' )
//	{
//		if ( pdemo->pvita_receiver->uManualTap > 0 )
//			pdemo->pvita_receiver->uManualTap--;
//		xil_printf( "\tuManualTap = %d\n\r", pdemo->pvita_receiver->uManualTap );
//	}
//}

	//return 0;
}

